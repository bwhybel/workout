{% extends 'base.html' %}
{% block content %}
<h1>{% block title %}writing a new workout{% endblock %} <span id="edited" style="color: red"></span></h1>
{% if not group %}
<p> uhh this isn't an actual group you can write workouts for </p>
{% else %}
<p><a href={{ url_for('workouts', group_id=group['id']) }}>{{ team['name'].lower() }} {{ group['name'].lower() }} workouts</a></p>
<p>
  new {{ team['name'].lower() }} {{ group['name'].lower() }} workout
</p>
<form action={{ url_for('workout', group_id=group['id']) }} method="post">
  <label for='id' style='display: none;'>id</label>
  <input type='text' id='id' name='id' style='display: none;' value='{{ id }}'>
  <label for='total_time'>time</label>
  <input type='text' id='total_time' name='total_time'>
  <label for='total_time_with_rest'>time with rest</label>
  <input type='text' id='total_time_with_rest' name='total_time_with_rest'>
  <label for='total_yards'>yards</label>
  <input type='text' id='total_yards' name='total_yards'><br />
  <label for='date'>date</label>
  <input type='text' pattern="\d\d\d\d-\d\d-\d\d" id='date' name='date' value='{{ date or today }}'>
  <label for='title'>title</label>
  <input type='text' id='title' name='title' value='{{ title }}'>
  <label for='rest_interval'>rest (minutes)</label>
  <input type='number' id='rest_interval' name='rest_interval' value='{{ rest_interval or 2 }}'><br />
  <textarea id='workout' name='workout_text' style='width: 100%;height: 50vh' rows='50' onkeyup='process(event, this)'>{{ workout_text }}</textarea><br />
  <input type="submit" value="save">
</form>
{% if id %}
<form action={{ url_for('delete_workout', workout_id=id) }}>
  <input type='submit' value='delete'>
</form>
{% endif %}
<button id="clickbind">pdf</button>
<form onsubmit='make_seconds()' action={{ url_for('download_seconds') }} method="post">
  <input style='display: none;' type='text' name='id' id='id' value='{{ id }}'>
  <input style='display: none;' type='text' name='date' id='date' value='{{ date }}'>
  <input style='display: none;' type='text' name='group' id='group' value="{{ group['name'] }}">
  <input style='display: none;' type='text' name='seconds_json' id='seconds_json'>
  <input type="submit" value="seconds">
</form>
<script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
<script>
  const setLine = new RegExp('^(\\s|{)*(\\d+)\\s*(x|\u{00D7})\\s*(\\d+)\\s*@\\s*(\\d\\d:\\d\\d|\\d:\\d\\d|:\\d\\d|\\d\\d|\\d)\\s+(.*)$');
  const noRepLine = new RegExp('^(\\d+)\\s*@\\s*(\\d\\d:\\d\\d|\\d:\\d\\d|:\\d\\d|\\d\\d|\\d)\\s+(.*)$');
  const roundLine = new RegExp('(\\d+)\\s*(x|\u{00D7})\\s*{$');
  const setDes = new RegExp('//\\s*(.*)');
  const noteLine = new RegExp('--\\s*(.*)');
  const endRoundLine = new RegExp('^}$');
  const restLine = new RegExp('^(\\d\\d:\\d\\d|\\d:\\d\\d|:\\d\\d)\\s*(.*)$')
  const time0 = new RegExp('^(\\d\\d):(\\d\\d)$');
  const time1 = new RegExp('^(\\d):(\\d\\d)$');
  const time2 = new RegExp('^:(\\d\\d)$');
  const time3 = new RegExp('^(\\d\\d)$');
  const time4 = new RegExp('^(\\d)$');
  let globalColor = 0;

  const timeToString = (data) => {
      let hours = Math.floor(data / 3600);
      data -= hours * 3600;
      let minutes = Math.floor(data / 60);
      data -= minutes * 60;
      let seconds = data;
      return hours.toString().padStart(2, '0') + ":" + minutes.toString().padStart(2, '0') + ":" + seconds.toString().padStart(2, '0');
  }

  const timeToInt = (data) => {
      console.log(data)
      if (time0.test(data)) {
          let array = time0.exec(data);
          return parseInt(array[1], 10) * 60 + parseInt(array[2], 10);
      }
      if (time1.test(data)) {
          let array = time1.exec(data);
          return parseInt(array[1], 10) * 60 + parseInt(array[2], 10);
      }
      if (time2.test(data)) {
          let array = time2.exec(data);
          return parseInt(array[1], 10);
      }
      if (time3.test(data)) {
          let array = time3.exec(data);
          return parseInt(array[1], 10);
      }
      if (time4.test(data)) {
          let array = time4.exec(data);
          return parseInt(array[1], 10) * 60;
      }
      alert("This is a problem");
      return 0;
  }

  // parse string into our custom object
  function getInfo(data) {
      const globalRestBetween = document.getElementById("rest_interval").value;
      const group = "{{ group['name'] }}"
      time_of_day = "";
      document.getElementsByName('time_of_day').forEach((element) => {
          if (element.checked) {
              time_of_day = element.value;
          }
      });
      info = {
          "date": document.getElementById('date').value.replace("/", "-"),
          "time_of_day": time_of_day,
          "group": group,
          "title": document.getElementById('title').value,
          "yards": 0,
          "time": 0,
          "rest": 0,
          "sets": []
      };
      currentRounds = 1;
      let currentSet = {
          des: "",
          lines: [],
          rounds: 1
      };
      let tooLong = false;
      data.forEach(line => {
          if (setLine.test(line)) {
              let array = setLine.exec(line);
              let rep = parseInt(array[2], 10);
              let dis = parseInt(array[4], 10);
              let int = array[5];
              let des = array[6];
              info.yards += currentRounds * rep * dis;
              info.time += currentRounds * rep * timeToInt(int);
              let currentLine = {
                  "rep": rep,
                  "dis": dis,
                  "int": int,
                  "des": des,
                  "notes": []
              };
              currentSet.lines.push(currentLine);
          } else if (noRepLine.test(line)) {
              let array = noRepLine.exec(line);
              let rep = 1;
              let dis = parseInt(array[1], 10);
              let int = array[2];
              let des = array[3];
              info.yards += currentRounds * dis;
              info.time += currentRounds * timeToInt(int);
              let currentLine = {
                  "rep": rep,
                  "dis": dis,
                  "int": int,
                  "des": des,
                  "notes": []
              };
              currentSet.lines.push(currentLine);
          } else if (roundLine.test(line)) {
              let array = roundLine.exec(line);
              currentRounds = parseInt(array[1], 10);
          } else if (restLine.test(line)) {
              let array = restLine.exec(line);
              let rep = 1;
              let dis = 0;
              let int = array[1];
              let des = array[2];
              info.time += currentRounds * timeToInt(int);
              let currentLine = {
                  "rep": rep,
                  "dis": dis,
                  "int": int,
                  "des": des,
                  "notes": []
              };
              currentSet.lines.push(currentLine);
          } else if (setDes.test(line)) {
              let array = setDes.exec(line);
              info.rest += timeToInt(globalRestBetween);
              currentSet.des = array[1];
          } else if (noteLine.test(line)) {
              let array = noteLine.exec(line);
              currentSet.lines.at(-1).notes.push(array[1]);
          } else if (endRoundLine.test(line)) {
              if (currentSet.lines.length != 0) {
                  currentSet.rounds = currentRounds;
                  info.sets.push(currentSet);
                  currentRounds = 1;
                  currentSet = {
                      des: "",
                      lines: [],
                      rounds: 1
                  };
              }
          } else if (line === "") {
              if (currentSet.lines.length != 0) {
                  currentSet.rounds = currentRounds;
                  info.sets.push(currentSet);
                  currentRounds = 1;
                  currentSet = {
                      des: "",
                      lines: [],
                      rounds: 1
                  };
              }
          }
          if (line.length > 55) {
              tooLong = true;
          }
      });
      if (currentSet.lines.length != 0) {
          currentSet.rounds = currentRounds;
          info.sets.push(currentSet);
      }
      globalInfo = info;
      if (tooLong) {
          document.getElementById("workout").style.color = "red";
      } else {
          document.getElementById("workout").style.color = "black";
      }
      return info;
  }

  const process = (e) => {
      let textArea = document.getElementById('workout').value;
      let originalTextArea = `{{ workout_text }}`.replace(/\s+/g, '')
      let newTextArea = textArea.replace(/\s+/g, '')
      console.log(newTextArea)
      console.log(originalTextArea)
      if (originalTextArea != newTextArea) {
	  document.getElementById('edited').innerHTML = 'edited!'
      } else {
	  document.getElementById('edited').innerHTML = ''
      }

      let array = textArea.split('\n');
      let info = getInfo(array);
      document.getElementById('total_yards').value = info.yards;
      document.getElementById('total_time').value = timeToString(info.time);
      document.getElementById('total_time_with_rest').value = timeToString(info.time + info.rest);
  }

  process()

  // use our custom object to create a pdf file and download it
  const makePdf = () => {
      const {
          jsPDF
      } = window.jspdf;
      const newLineDist = 17;
      const smallerSpace = 12;
      const tab = 25;
      const margin = 20;

      let pdf = new jsPDF({
          unit: 'px'
      });
      logo_width = {{ team['logo_width'] }};
      pdf.addImage("{{ team['image'] }}", 'jpeg', (426.5 - logo_width), 20, logo_width, 80);
      pdf.setFont("Courier", "normal");
      pdf.setFontSize(32);

      pdf.text("{{ group['name'] }}", margin, 36);
      pdf.setFontSize(20);
      pdf.text(globalInfo.date, margin, 56);
      pdf.setFontSize(18);
      pdf.setFont("Courier", "italic");
      pdf.text(globalInfo.title, margin, 76);

      pdf.setFontSize(16);
      pdf.setFont("Courier", "normal");

      let left = margin;
      let top = 94;
      globalInfo.sets.forEach(set => {
          pdf.setFont("Courier", "bold");
          if (set.des) {
	      pdf.text(set.des, left, top);
	      top += newLineDist;
          }
          pdf.setFont("Courier", "normal");
          if (set.rounds != 1) {
	      pdf.text(set.rounds + " x {", left, top);
	      left = margin + tab;
	      top += newLineDist;
          }
          set.lines.forEach(line => {
	      pdf.text((line.rep > 1 ? line.rep + " x " : "") + (line.dis > 0 ? line.dis + " @ " : "") + line.int + " " + line.des, left, top);
	      if (line.notes.length > 0) {
                  pdf.setFontSize(12);
                  pdf.setFont("Courier", "italic");
                  line.notes.forEach(note => {
		      top += smallerSpace;
		      pdf.text('\u2022 ' + note, left + tab, top);
                  });
                  pdf.setFontSize(16);
                  pdf.setFont("Courier", "normal");
	      }
	      top += newLineDist;
          });
          if (left === margin + tab) {
	      left = margin;
          }
          top += smallerSpace;
      });
      pdf.save(globalInfo.date + "_" + globalInfo.group + ".pdf");
  };
  // use our custom object to create a seconds file to use in the app
  const make_seconds = () => {
      const globalRestBetween = document.getElementById("rest_interval").value;
      let seconds = {};
      seconds._type = "pack";
      seconds.name = "Shared Timers";
      seconds.items = [];
      let folder = {};
      folder._type = "pack";
      folder.name = "{{ team['name'] }} {{ group['name'] }} " + globalInfo.date;
      folder.color = 3;
      folder.items = [];
      globalInfo.sets.forEach(setItem => {
          let set = {};
          set.overrun = false;
          set._type = "cust";
          set.type = 0;
          set.name = setItem.des;
          set.soundScheme = 1;
          set.activity = 46;
          set.intervals = [];
          for (let i = 0; i < setItem.rounds; i++) {
	      setItem.lines.forEach(line => {
                  for (let j = 0; j < line.rep; j++) {
		      let secondsLine = {};
		      secondsLine.splitRest = 0;
		      secondsLine.ducked = false;
		      secondsLine.rest = false;
		      secondsLine.color = (globalColor % 9) + 1;
		      secondsLine.indefinite = false;
		      secondsLine.split = false;
		      secondsLine.vibration = false;
		      secondsLine.halfwayAlert = false;
		      secondsLine.duration = timeToInt(line.int);
		      secondsLine._type = "int";
		      secondsLine.name = (line.dis > 0 ? line.dis + " " : "") + line.des;

		      set.intervals.push(secondsLine);
                  }
                  globalColor++;
	      });
          }
          folder.items.push(set);
      });

      let wholeWorkout = {};
      wholeWorkout.overrun = false;
      wholeWorkout._type = "cust";
      wholeWorkout.type = 0;
      wholeWorkout.name = "Everything";
      wholeWorkout.soundScheme = 1;
      wholeWorkout.activity = 46;
      wholeWorkout.intervals = [];
      globalInfo.sets.forEach(setItem => {
          let restLine = {};
          restLine.splitRest = 0;
          restLine.ducked = false;
          restLine.rest = false;
          restLine.color = (globalColor % 9) + 1;
          restLine.indefinite = false;
          restLine.split = false;
          restLine.vibration = false;
          restLine.halfwayAlert = false;
          restLine.duration = timeToInt(globalRestBetween);
          restLine._type = "int";
          restLine.name = "Rest, Setting up Next Set";

	  if(setItem.des) {
	      wholeWorkout.intervals.push(restLine);
	      globalColor++;
	  }
          for (let i = 0; i < setItem.rounds; i++) {
	      setItem.lines.forEach(line => {
                  for (let j = 0; j < line.rep; j++) {
		      let secondsLine = {};
		      secondsLine.splitRest = 0;
		      secondsLine.ducked = false;
		      secondsLine.rest = false;
		      secondsLine.color = (globalColor % 9) + 1;
		      secondsLine.indefinite = false;
		      secondsLine.split = false;
		      secondsLine.vibration = false;
		      secondsLine.halfwayAlert = false;
		      secondsLine.duration = timeToInt(line.int);
		      secondsLine._type = "int";
		      name_distance = (line.dis > 0 ? line.dis + " " : "")
		      name_set_num = (line.rep == 1 ? "" : " (" + (j + 1) + "/" + line.rep + ")")
		      name_round_num = (setItem.rounds == 1 ? "" : " [" + (i + 1) + "/" + setItem.rounds + "]")
		      secondsLine.name = name_distance + line.des + name_set_num + name_round_num;

		      wholeWorkout.intervals.push(secondsLine);
                  }
                  globalColor++;
	      });
          }
          globalColor++;
      });
      folder.items.push(wholeWorkout);


      seconds.items.push(folder);

      document.getElementById('seconds_json').value = JSON.stringify(seconds)
  }

  let pdfButton = document.getElementById("clickbind");
  pdfButton.addEventListener("click", makePdf);
</script>
{% endif %}
{% endblock %}
