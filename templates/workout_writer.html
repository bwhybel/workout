{% extends 'base.html' %}
{% block content %}
<h1>{% block title %}writing a new workout{% endblock %}</h1>
{% if not group %}
<p> uhh this isn't an actual group you can write workouts for </p>
{% else %}
    <p><a href={{ url_for('workouts', group_id=group['id']) }}>{{ team['name'].lower() }} {{ group['name'].lower() }} workouts</a></p>
    <p>
      new {{ team['name'].lower() }} {{ group['name'].lower() }} workout<br />
    </p>
    <form action={{ url_for('workout', group_id=group['id']) }} method="post">
      <label for='id' style='display: none;'>id</label>
      <input type='text' id='id' name='id' style='display: none;' value='{{ id }}'><br />
      <label for='total_time'>time</label>
      <input type='text' id='total_time' name='total_time'><br />
      <label for='total_time_with_rest'>time with rest</label>
      <input type='text' id='total_time_with_rest' name='total_time_with_rest'><br />
      <label for='total_yards'>yards</label>
      <input type='text' id='total_yards' name='total_yards'><br />
      <label for='date'>date</label>
      <input type='text' pattern="\d\d\d\d-\d\d-\d\d" id='date' name='date' value='{{ date or today }}'><br />
      <label for='title'>title</label>
      <input type='text' id='title' name='title' value='{{ title }}'><br />
      <label for='rest_interval'>rest (minutes)</label>
      <input type='number' id='rest_interval' name='rest_interval' value='{{ rest_interval or 2 }}'><br />
      <textarea id='workout' name='workout_text' cols='100' rows='50' onkeyup='process(event, this)'>{{ workout_text }}</textarea><br />
      <input type="submit" value="save">
    </form>
    {% if id %}
    <a href={{ url_for('delete_workout', workout_id=id) }}>delete</a>
    {% endif %}
    <button id="clickbind">pdf</button>
    <button id="clickbind2">seconds</button>
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
    <script>
      const setLine = new RegExp('^(\\s|{)*(\\d+)\\s*(x|\u{00D7})\\s*(\\d+)\\s*@\\s*(\\d\\d:\\d\\d|\\d:\\d\\d|:\\d\\d|\\d\\d|\\d)\\s+(.*)$');
      const noRepLine = new RegExp('^(\\d+)\\s*@\\s*(\\d\\d:\\d\\d|\\d:\\d\\d|:\\d\\d|\\d\\d|\\d)\\s+(.*)$');
      const roundLine = new RegExp('(\\d+)\\s*(x|\u{00D7})\\s*{$');
      const setDes = new RegExp('//\\s*(.*)');
      const noteLine = new RegExp('--\\s*(.*)');
      const endRoundLine = new RegExp('^}$');
      const restLine = new RegExp('^(\\d\\d:\\d\\d|\\d:\\d\\d|:\\d\\d)\\s*(.*)$')
      const time0 = new RegExp('^(\\d\\d):(\\d\\d)$');
      const time1 = new RegExp('^(\\d):(\\d\\d)$');
      const time2 = new RegExp('^:(\\d\\d)$');
      const time3 = new RegExp('^(\\d\\d)$');
      const time4 = new RegExp('^(\\d)$');
      let globalColor = 0;

      const timeToString = (data) => {
          let hours = Math.floor(data / 3600);
          data -= hours * 3600;
          let minutes = Math.floor(data / 60);
          data -= minutes * 60;
          let seconds = data;
          return hours.toString().padStart(2, '0') + ":" + minutes.toString().padStart(2, '0') + ":" + seconds.toString().padStart(2, '0');
      }

      const timeToInt = (data) => {
	  console.log(data)
          if (time0.test(data)) {
              let array = time0.exec(data);
              return parseInt(array[1], 10) * 60 + parseInt(array[2], 10);
          }
          if (time1.test(data)) {
              let array = time1.exec(data);
              return parseInt(array[1], 10) * 60 + parseInt(array[2], 10);
          }
          if (time2.test(data)) {
              let array = time2.exec(data);
              return parseInt(array[1], 10);
          }
          if (time3.test(data)) {
              let array = time3.exec(data);
              return parseInt(array[1], 10);
          }
          if (time4.test(data)) {
              let array = time4.exec(data);
              return parseInt(array[1], 10) * 60;
          }
          alert("This is a problem");
          return 0;
      }

      // parse string into our custom object
      function getInfo(data) {
          const globalRestBetween = document.getElementById("rest_interval").value;
          const group = "{{ group['name'] }}"
          time_of_day = "";
          document.getElementsByName('time_of_day').forEach((element) => {
              if (element.checked) {
                  time_of_day = element.value;
              }
          });
          info = {
              "date": document.getElementById('date').value.replace("/", "-"),
              "time_of_day": time_of_day,
              "group": group,
              "title": document.getElementById('title').value,
              "yards": 0,
              "time": 0,
              "rest": 0,
              "sets": []
          };
          currentRounds = 1;
          let currentSet = {
              des: "",
              lines: [],
              rounds: 1
          };
          let tooLong = false;
          data.forEach(line => {
              if (setLine.test(line)) {
                  let array = setLine.exec(line);
                  let rep = parseInt(array[2], 10);
                  let dis = parseInt(array[4], 10);
                  let int = array[5];
                  let des = array[6];
                  info.yards += currentRounds * rep * dis;
                  info.time += currentRounds * rep * timeToInt(int);
                  let currentLine = {
                      "rep": rep,
                      "dis": dis,
                      "int": int,
                      "des": des,
                      "notes": []
                  };
                  currentSet.lines.push(currentLine);
              } else if (noRepLine.test(line)) {
                  let array = noRepLine.exec(line);
                  let rep = 1;
                  let dis = parseInt(array[1], 10);
                  let int = array[2];
                  let des = array[3];
                  info.yards += currentRounds * dis;
                  info.time += currentRounds * timeToInt(int);
                  let currentLine = {
                      "rep": rep,
                      "dis": dis,
                      "int": int,
                      "des": des,
                      "notes": []
                  };
                  currentSet.lines.push(currentLine);
              } else if (roundLine.test(line)) {
                  let array = roundLine.exec(line);
                  currentRounds = parseInt(array[1], 10);
              } else if (restLine.test(line)) {
                  let array = restLine.exec(line);
                  let rep = 1;
                  let dis = 0;
                  let int = array[1];
                  let des = array[2];
                  info.time += currentRounds * timeToInt(int);
                  let currentLine = {
                      "rep": rep,
                      "dis": dis,
                      "int": int,
                      "des": des,
                      "notes": []
                  };
                  currentSet.lines.push(currentLine);
              } else if (setDes.test(line)) {
                  let array = setDes.exec(line);
                  info.rest += timeToInt(globalRestBetween);
                  currentSet.des = array[1];
              } else if (noteLine.test(line)) {
                  let array = noteLine.exec(line);
                  currentSet.lines.at(-1).notes.push(array[1]);
              } else if (endRoundLine.test(line)) {
                  if (currentSet.lines.length != 0) {
                      currentSet.rounds = currentRounds;
                      info.sets.push(currentSet);
                      currentRounds = 1;
                      currentSet = {
                          des: "",
                          lines: [],
                          rounds: 1
                      };
                  }
              } else if (line === "") {
                  if (currentSet.lines.length != 0) {
                      currentSet.rounds = currentRounds;
                      info.sets.push(currentSet);
                      currentRounds = 1;
                      currentSet = {
                          des: "",
                          lines: [],
                          rounds: 1
                      };
                  }
              }
              if (line.length > 55) {
                  tooLong = true;
              }
          });
          if (currentSet.lines.length != 0) {
              currentSet.rounds = currentRounds;
              info.sets.push(currentSet);
          }
          globalInfo = info;
          if (tooLong) {
              document.getElementById("workout").style.color = "red";
          } else {
              document.getElementById("workout").style.color = "black";
          }
          return info;
      }

      const process = (e) => {
          let textArea = document.getElementById('workout').value;
          let array = textArea.split('\n');
          let info = getInfo(array);
          document.getElementById('total_yards').value = info.yards;
          document.getElementById('total_time').value = timeToString(info.time);
          document.getElementById('total_time_with_rest').value = timeToString(info.time + info.rest);
      }

      process()

      // use our custom object to create a pdf file and download it
      const makePdf = () => {
	  const {
              jsPDF
	  } = window.jspdf;
	  const newLineDist = 17;
	  const smallerSpace = 12;
	  const tab = 25;
	  const margin = 20;

	  let pdf = new jsPDF({
              unit: 'px'
	  });
	  logo_width = {{ team['logo_width'] }};
	  pdf.addImage("{{ team['image'] }}", 'jpeg', (426.5 - logo_width), 20, logo_width, 80);
	  pdf.setFont("Courier", "normal");
	  pdf.setFontSize(32);

	  pdf.text("{{ group['name'] }}", margin, 36);
	  pdf.setFontSize(20);
	  pdf.text(globalInfo.date, margin, 56);
	  pdf.setFontSize(18);
	  pdf.setFont("Courier", "italic");
	  pdf.text(globalInfo.title, margin, 76);

	  pdf.setFontSize(16);
	  pdf.setFont("Courier", "normal");

	  let left = margin;
	  let top = 94;
	  globalInfo.sets.forEach(set => {
              pdf.setFont("Courier", "bold");
              if (set.des) {
		  pdf.text(set.des, left, top);
		  top += newLineDist;
              }
              pdf.setFont("Courier", "normal");
              if (set.rounds != 1) {
		  pdf.text(set.rounds + " x {", left, top);
		  left = margin + tab;
		  top += newLineDist;
              }
              set.lines.forEach(line => {
		  pdf.text((line.rep > 1 ? line.rep + " x " : "") + (line.dis > 0 ? line.dis + " @ " : "") + line.int + " " + line.des, left, top);
		  if (line.notes.length > 0) {
                      pdf.setFontSize(12);
                      pdf.setFont("Courier", "italic");
                      line.notes.forEach(note => {
			  top += smallerSpace;
			  pdf.text('\u2022 ' + note, left + tab, top);
                      });
                      pdf.setFontSize(16);
                      pdf.setFont("Courier", "normal");
		  }
		  top += newLineDist;
              });
              if (left === margin + tab) {
		  left = margin;
              }
              top += smallerSpace;
	  });
	  pdf.save(globalInfo.date + "_" + globalInfo.group + ".pdf");
      };
      // use our custom object to create a seconds file to use in the app
      const makeSeconds = () => {
	  const globalRestBetween = document.getElementById("rest_interval").value;
	  let seconds = {};
	  seconds._type = "pack";
	  seconds.name = "Shared Timers";
	  seconds.items = [];
	  let folder = {};
	  folder._type = "pack";
	  folder.name = "{{ team['name'] }} {{ group['name'] }} " + globalInfo.date;
	  folder.color = 3;
	  folder.items = [];
	  globalInfo.sets.forEach(setItem => {
              let set = {};
              set.overrun = false;
              set._type = "cust";
              set.type = 0;
              set.name = setItem.des;
              set.soundScheme = 1;
              set.activity = 46;
              set.intervals = [];
              for (let i = 0; i < setItem.rounds; i++) {
		  setItem.lines.forEach(line => {
                      for (let j = 0; j < line.rep; j++) {
			  let secondsLine = {};
			  secondsLine.splitRest = 0;
			  secondsLine.ducked = false;
			  secondsLine.rest = false;
			  secondsLine.color = (globalColor % 9) + 1;
			  secondsLine.indefinite = false;
			  secondsLine.split = false;
			  secondsLine.vibration = false;
			  secondsLine.halfwayAlert = false;
			  secondsLine.duration = timeToInt(line.int);
			  secondsLine._type = "int";
			  secondsLine.name = (line.dis > 0 ? line.dis + " " : "") + line.des;

			  set.intervals.push(secondsLine);
                      }
                      globalColor++;
		  });
              }
              folder.items.push(set);
	  });

	  let wholeWorkout = {};
	  wholeWorkout.overrun = false;
	  wholeWorkout._type = "cust";
	  wholeWorkout.type = 0;
	  wholeWorkout.name = "Everything";
	  wholeWorkout.soundScheme = 1;
	  wholeWorkout.activity = 46;
	  wholeWorkout.intervals = [];
	  globalInfo.sets.forEach(setItem => {
              let restLine = {};
              restLine.splitRest = 0;
              restLine.ducked = false;
              restLine.rest = false;
              restLine.color = (globalColor % 9) + 1;
              restLine.indefinite = false;
              restLine.split = false;
              restLine.vibration = false;
              restLine.halfwayAlert = false;
              restLine.duration = timeToInt(globalRestBetween);
              restLine._type = "int";
              restLine.name = "Rest, Setting up Next Set";

	      if(setItem.des) {
		  wholeWorkout.intervals.push(restLine);
		  globalColor++;
	      }
              for (let i = 0; i < setItem.rounds; i++) {
		  setItem.lines.forEach(line => {
                      for (let j = 0; j < line.rep; j++) {
			  let secondsLine = {};
			  secondsLine.splitRest = 0;
			  secondsLine.ducked = false;
			  secondsLine.rest = false;
			  secondsLine.color = (globalColor % 9) + 1;
			  secondsLine.indefinite = false;
			  secondsLine.split = false;
			  secondsLine.vibration = false;
			  secondsLine.halfwayAlert = false;
			  secondsLine.duration = timeToInt(line.int);
			  secondsLine._type = "int";
			  name_distance = (line.dis > 0 ? line.dis + " " : "")
			  name_set_num = (line.rep == 1 ? "" : " (" + (j + 1) + "/" + line.rep + ")")
			  name_round_num = (setItem.rounds == 1 ? "" : " [" + (i + 1) + "/" + setItem.rounds + "]")
			  secondsLine.name = name_distance + line.des + name_set_num + name_round_num;

			  wholeWorkout.intervals.push(secondsLine);
                      }
                      globalColor++;
		  });
              }
              globalColor++;
	  });
	  folder.items.push(wholeWorkout);


	  seconds.items.push(folder);

	  let element = document.createElement('a');
	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(seconds)));
	  element.setAttribute('download', globalInfo.date + "_" + globalInfo.group + ".seconds");

	  element.style.display = 'none';
	  document.body.appendChild(element);

	  element.click();

	  document.body.removeChild(element);
      }

      let pdfButton = document.getElementById("clickbind");
      pdfButton.addEventListener("click", makePdf);

      let secondsButton = document.getElementById("clickbind2");
      secondsButton.addEventListener("click", makeSeconds);

    </script>
    {% endif %}
{% endblock %}
